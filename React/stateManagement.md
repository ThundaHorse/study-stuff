#State Management
---

Implementing a user interface has many ideas, some of the most popular are:
- UI should derive entirely from an application _state_
- Application state should be externalized in a single source of truth and modified by carefully controlled mutations.

The idea is simple but implementation is where it can get tricky.

---
## Model-view-intent Architecture
---

User interface state, and controlling how changes are made to that state.

- ___State containers___ | ___Redux___ | ___React-redux___

Model-view-intent architecture is the architecture of a well-designed React App. Also appears in `Elm` and `CycleJS`.

Described by ___3___ components.

1. ___Model___: A single object that completely describes the state of the user interface.
2. ___View___: Function that transforms the model into a user interface.
   - The model is the model is the input to the view function and the user interface is the output.
     - _Model_ -> _View_ -> _UI_
   - When the model changes, the view function can generate the corresponding user interface.
3. ___Intent___: The UI generated by the view function produces 'Intent'. Thins the user wants to do.
   - User selecting an answer on a quiz is intent.
   - The intent is produced, it is applied to the model creating and updated model.
     - The updated model is then passed through to the view function to produce the updated UI.

### Why is this so good?

1. The model is the total source of truth. The entire UI is described by the model.
2. The view produces the UI based on noting but the model.
3. Model can only be changed by processing intents on the current model.

Look at it this way,

The model is a set of possible states and intents are possible transitions.
Intents transition the model from one state to the next.

Here's some pseudocode:

```javascript
let model = {}; // Model is an object
let view = (m) => <...>; // View is a function from the model to a user interface
let update = (m, intent) => m2; // Update is a function that applies an intent to a model
```

---
## State Container
---

A ___State container___ is a component that takes care of holding a model nnd controlling updates through a model.

Some examples of state methods:
- `getState()`: returns the current application state object held by state container.
- `dispatch()`: applies an intent held by the application state. Producing a new application state.
- `subscribe()`: registers a callback to be called when the application state changes.
  - When an intent is passed to a dispatch method.

### Stopwatch App example with custom state

```javascript 
const update = (model = { running: false, time: 0 }, intent) => {
  const updates = {
    'START': (model) => Object.assign(model, {running: true}),
    'STOP': (model) => Object.assign(model, {running: false}),
    'TICK': (model) => Object.assign(model, {time: model.time + (model.running ? 1 : 0)})
  };
  return (updates[intent] || (() => model))(model);
};

let view = (m) => {
  let minutes = Math.floor(m.time / 60);
  let seconds = m.time - (minutes * 60);
  let secondsFormatted =  `${seconds < 10 ? '0' : ''}${seconds}`;
  let handler = (event) => {
    container.dispatch(m.running ? 'STOP' : 'START');
  };
  
  return <div>
    <p>{minutes}:{secondsFormatted}</p>
    <button onClick={handler}>{m.running ? 'Stop' : 'Start'}</button>
  </div>;
};

const createStore = (reducer) => {
  let internalState;
  let handlers = [];
  return {
    dispatch: (intent) => {
      internalState = reducer(internalState, intent);
      handlers.forEach(h => { h(); });
    },
    subscribe: (handler) => {
      handlers.push(handler);
    },
    getState: () => internalState
  };
};

let container = createStore(update);

const render = () => {
  ReactDOM.render(view(container.getState()),
    document.getElementById('root')
  );
};
container.subscribe(render);

setInterval(() => {
  container.dispatch('TICK');
}, 1000);

```

